<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图论</title>
      <link href="/2023/08/20/%E5%9B%BE%E8%AE%BA/"/>
      <url>/2023/08/20/%E5%9B%BE%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="稀疏图与稠密图"><a href="#稀疏图与稠密图" class="headerlink" title="稀疏图与稠密图"></a>稀疏图与稠密图</h2><p> 概念：<br>  有很少条边或弧的图称为稀疏图，反之称为稠密图。 这里稀疏和稠密是模糊的概念，都是相对而言的。目前为止还没有给出一个量化的定义。比方说一个有 100 个顶点、200 条边的图，与 100 个顶点组成的完全图相比，他的边很少，也就是所谓的稀疏了。<br>用n表示图中顶点数目，用e表示图中边或弧的数目<br>  稀疏图: <code>e &lt; nlogn</code><br>  稠密图: <code>e &gt; nlogn</code><br>若图中边或弧上有权，则该图称为网<br>  稠密图用邻接矩阵存储<br>  稀疏图用邻接表存储  </p><p>原因：<br>  邻接表只存储非零节点，而邻接矩阵则要把所有的节点信息(非零节点与零节点)都存储下来。<br>  稀疏图的非零节点不多，所以选用邻接表效率高，如果选用稠密图就会造成很多空间的浪费，矩阵中大多数都会是零节点！稠密图的非零界点多，零节点少，选用邻接矩阵是最适合不过！</p><h2 id="树与图的dfs"><a href="#树与图的dfs" class="headerlink" title="树与图的dfs"></a>树与图的dfs</h2><h3 id="树的重心"><a href="#树的重心" class="headerlink" title="树的重心"></a>树的重心</h3><p>重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。</p><p><img src="https://cdn.acwing.com/media/article/image/2020/05/22/652_ab4f9f7c9b-1.png" alt=""></p><p>删除 1 号点，剩余各个连通块中点数的最大值最小为 4 .</p><p>思路 ： 统计删除结点中（包括删除的结点 <code>size</code>）的每颗子树中的最大结点数 ， <code>n - size</code> 统计已删除结点的父结点中结点数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回以u为根的子树中节点的个数，包括u节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">//存储 删掉某个节点之后，最大的连通子图节点数</span></span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">//标记访问过u节点</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>; <span class="comment">//存储 以u为根的树 的节点数, 包括u，如图中的4号节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问u的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过</span></span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);  <span class="comment">// u节点的单棵子树节点数 如图中的size值</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, s); <span class="comment">// 记录最大联通子图的节点数</span></span><br><span class="line">            sum += s; <span class="comment">//以j为根的树 的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n-sum 如图中的n-size值，不包括根节点4；</span></span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum); <span class="comment">// 选择u节点为重心，最大的 连通子图节点数</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res, ans); <span class="comment">//遍历过的假设重心中，最小的最大联通子图的 节点数</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树与图的bfs"><a href="#树与图的bfs" class="headerlink" title="树与图的bfs"></a>树与图的bfs</h2><h3 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title="图中点的层次"></a>图中点的层次</h3><p>走迷宫找 1 号点到 n 号点的最短距离，但是可能存在环<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(u);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> c = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[c]; ~ i; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[j] = d[c] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h2><p><img src="https://cdn.acwing.com/media/article/image/2019/12/13/1833_db6dffa81d-37ff39642fd8f74476ddcd99944d1b4.png" alt=""></p><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>迪杰斯特拉算法采用的是一种贪心的策略。</p><h4 id="Dijkstra求最短路-I-O-n-2"><a href="#Dijkstra求最短路-I-O-n-2" class="headerlink" title="Dijkstra求最短路 I $(O(n^2))$"></a>Dijkstra求最短路 I $(O(n^2))$</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dist));<span class="comment">//dist 数组的各个元素为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//源点到源点的距离为置为 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//遍历 dist 数组，找到没有确定最短路径的节点中距离源点最近的点t</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!state[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state[t] = <span class="number">1</span>;<span class="comment">//state[i] 置为 1。</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//遍历 t 所有可以到达的节点 i</span></span><br><span class="line">        &#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);<span class="comment">//更新 dist[j]</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="Dijkstra求最短路-II-O-mlogn"><a href="#Dijkstra求最短路-II-O-mlogn" class="headerlink" title="Dijkstra求最短路 II $(O(mlogn))$"></a>Dijkstra求最短路 II $(O(mlogn))$</h4><p>算法的主要耗时的步骤是从<code>dist</code> 数组中选出：没有确定最短路径的节点中距离源点最近的点 <code>t</code>。只是找个最小值而已，没有必要每次遍历一遍<code>dist</code>数组。</p><p>在一组数中每次能很快的找到最小值，很容易想到使用小根堆。可以使用库中的小根堆。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);<span class="comment">//距离初始化为无穷大</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<span class="comment">//小根堆</span></span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);<span class="comment">//插入距离和节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();<span class="comment">//取距离源点最近的点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;<span class="comment">//ver:节点编号，distance:源点距离ver 的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;<span class="comment">//如果距离已经确定，则跳过该点</span></span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])<span class="comment">//更新ver所指向的节点距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);<span class="comment">//距离变小，则入堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h3><p>松弛的概念:  </p><ol><li>考虑节点<code>u</code>以及它的邻居<code>v</code>，从起点跑到<code>v</code>有好多跑法，有的跑法经过<code>u</code>，有的不经过。 </li><li>经过<code>u</code>的跑法的距离就是<code>distu + u</code>到<code>v</code>的距离。  </li><li>所谓松弛操作，就是看一看<code>distv</code>和<code>distu + u</code>到<code>v</code>的距离哪个大一点。<br>如果前者大一点，就说明当前的不是最短路，就要赋值为后者，这就叫做松弛。  </li></ol><p><code>Bellman_ford</code> 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 <code>n - 1</code> 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。 </p><h4 id="有边数限制的最短路"><a href="#有边数限制的最短路" class="headerlink" title="有边数限制的最短路"></a>有边数限制的最短路</h4><p>为什么是<code>dist[n] &gt; 0x3f3f3f3f/2</code>， 而不是<code>dist[n] &gt; 0x3f3f3f3f</code> ?<br>5号节点距离起点的距离是无穷大，利用5号节点更新<code>n</code>号节点距离起点的距离，将得到$10^9−2$, 虽然小于$10^9$, 但并不存在最短路，(在边数限制在<code>k</code>条的条件下)。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;<span class="comment">//k次循环 走过k条边</span></span><br><span class="line">        <span class="built_in">memcpy</span>(back, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;<span class="comment">//遍历所有边</span></span><br><span class="line">            <span class="type">int</span> a = e[j].a, b = e[j].b, w = e[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], back[a] + w);</span><br><span class="line">            <span class="comment">//使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h3><p><code>Bellman_ford</code> 算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><p><code>Bellman_ford</code> 算法里最后<code>return -1</code>的判断条件写的是<code>dist[n] &gt; 0x3f3f3f3f/2</code>;而 <code>spfa</code> 算法写的是 <code>dist[n] == 0x3f3f3f3f</code> 其原因在于 <code>Bellman_ford</code> 算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是<code>SPFA</code>算法不一样，它相当于采用了<code>BFS</code>，因此遍历到的结点都是与源点连通的，因此如果你要求的 <code>n</code> 和源点不连通，它不会得到更新，还是保持的<code>0x3f3f3f3f</code>。</p><p><code>Bellman_ford</code> 算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是 <code>SPFA</code> 算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用 <code>SPFA</code> 否则会死循环。</p><p>由于 <code>SPFA</code> 算法是由 <code>Bellman_ford</code> 算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 <code>O(nm)</code> ，假如题目时间允许可以直接用 <code>SPFA</code> 算法去解 <code>Dijkstra</code> 算法的题目。</p><p>求负环一般使用<code>SPFA</code>算法，方法是用一个<code>cnt</code>数组记录每个点到源点的边数，一个点被更新一次就 <code>+1</code>，一旦有点的边数达到了 <code>n</code> 那就证明存在了负环。</p><h4 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title="spfa求最短路"></a>spfa求最短路</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> t = p.se;</span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i]; </span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;<span class="comment">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title="spfa判断负环"></a>spfa判断负环</h4><p>方法 1：统计每个点入队的次数，如果某个点入队 n 次，则说明存在负环  </p><p>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于 n，则也说明存在环<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里不需要初始化dist数组为 正无穷/初始化的原因是， 如果存在负环， 那么dist不管初始化为多少， 都会被更新</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不仅仅是1了， 因为点1可能到不了有负环的点， 因此把所有点都加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i]=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[t];i!=<span class="number">-1</span>; i=ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])&#123;</span><br><span class="line">                dist[j] = dist[t]+w[i];</span><br><span class="line">                cnt[j] = cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><h4 id="Floyd求最短路"><a href="#Floyd求最短路" class="headerlink" title="Floyd求最短路"></a>Floyd求最短路</h4><p><code>d[i][k]</code> 是 <code>INF</code> 但是 <code>d[k][j]</code>是 <code>-2</code> 因为 <code>i</code> 是到不了 <code>k</code> 的, 所以 <code>k</code> 也是到不了 <code>j</code> 的, 那么 <code>i</code> 就到不了 <code>j</code> .<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最小生成树问题"><a href="#最小生成树问题" class="headerlink" title="最小生成树问题"></a>最小生成树问题</h2><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><p>Dijkstra算法是更新到起始点的距离，Prim是更新到集合S的距离</p><h4 id="Prim算法求最小生成树"><a href="#Prim算法求最小生成树" class="headerlink" title="Prim算法求最小生成树"></a>Prim算法求最小生成树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dist[t] == <span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//处理独立点，判断是否连通，有无最小生成树</span></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        res += dist[t];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><h4 id="Kruskal算法求最小生成树"><a href="#Kruskal算法求最小生成树" class="headerlink" title="Kruskal算法求最小生成树"></a>Kruskal算法求最小生成树</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//保存并查集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> &amp;W) <span class="type">const</span>&#123;<span class="comment">//通过边长进行排序</span></span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;edg[N * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;<span class="comment">//并查集找祖宗</span></span><br><span class="line">    <span class="keyword">if</span>(p[a] != a) p[a] = <span class="built_in">find</span>(p[a]);</span><br><span class="line">    <span class="keyword">return</span> p[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//依次尝试加入每条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pa = <span class="built_in">find</span>(edg[i].a)；<span class="comment">// a 点所在的集合</span></span><br><span class="line">        <span class="type">int</span> pb = <span class="built_in">find</span>(edg[i].b);<span class="comment">// b 点所在的集合</span></span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;<span class="comment">//如果 a b 不在一个集合中</span></span><br><span class="line">            res += edg[i].w;<span class="comment">//a b 之间这条边要</span></span><br><span class="line">            p[pa] = pb;<span class="comment">// 合并a b</span></span><br><span class="line">            cnt ++; <span class="comment">// 保留的边数量+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;<span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;<span class="comment">//读入每条边</span></span><br><span class="line">        <span class="type">int</span> a, b , c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt;c;</span><br><span class="line">        edg[i] = &#123;a, b, c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(edg + <span class="number">1</span>, edg + m + <span class="number">1</span>);<span class="comment">//按边长排序</span></span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) &#123;<span class="comment">//如果保留的边小于点数-1，则不能连通</span></span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="二分图问题"><a href="#二分图问题" class="headerlink" title="二分图问题"></a>二分图问题</h2><p>定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。</p><h3 id="判定二分图"><a href="#判定二分图" class="headerlink" title="判定二分图"></a>判定二分图</h3><ol><li>开始对任意一未染色的顶点染色。</li><li>判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。</li><li>若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。<h4 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h4></li></ol><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span> * <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> e[N], ne[N], idx;<span class="comment">//邻接表存储图</span></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> color[N];<span class="comment">//保存各个点的颜色，0 未染色，1 是红色，2 是黑色</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//点和边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//邻接表插入点和边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx]= h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span><span class="comment">//深度优先遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;<span class="comment">//u的点成 c 染色</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历和 u 相邻的点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i!= <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> b = e[i];                   </span><br><span class="line">        <span class="keyword">if</span>(!color[b])<span class="comment">//相邻的点没有颜色,则递归处理这个相邻点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(b, <span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）</span></span><br><span class="line">         <span class="comment">//（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[b] &amp;&amp; color[b] != <span class="number">3</span> - c)<span class="comment">//如果已经染色，判断颜色是否为 3 - c</span></span><br><span class="line">        &#123;                                     </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果不是，说明冲突，返回                   </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);<span class="comment">//初始化邻接表</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//读入边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//遍历点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])<span class="comment">//如果没染色</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i, <span class="number">1</span>))<span class="comment">//染色该点，并递归处理和它相邻的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;<span class="comment">//出现矛盾，输出NO </span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;<span class="comment">//全部染色完成，没有矛盾，输出YES</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h3><h4 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h4><p>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归找可以匹配的点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 和各个点尝试能否匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> b = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[b])&#123;<span class="comment">//打标记</span></span><br><span class="line">            st[b] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 当前尝试点没有被匹配或者和当前尝试点匹配的那个点可以换另一个匹配</span></span><br><span class="line">            <span class="keyword">if</span>(match[b] == <span class="number">0</span> || <span class="built_in">find</span>(match[b]))&#123;</span><br><span class="line">                <span class="comment">// 和当前尝试点匹配在一起</span></span><br><span class="line">                match[b] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划dp</title>
      <link href="/2023/08/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/"/>
      <url>/2023/08/15/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92dp/</url>
      
        <content type="html"><![CDATA[<h1 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h1><h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><h3 id="最长上升子序列-I-O-n-2"><a href="#最长上升子序列-I-O-n-2" class="headerlink" title="最长上升子序列 I ($O(n^2)$)"></a>最长上升子序列 I ($O(n^2)$)</h3><p>求数值严格单调递增的子序列的长度最长是多少?</p><p>状态：$f[i]$ 表示 <code>i</code> 位置记录的严格单调递增的子序列的最大长度<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    f[i] = <span class="number">1</span>; <span class="comment">// 每个数最小长度为 1</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )&#123; </span><br><span class="line">        <span class="keyword">if</span>(arr[j] &lt; arr[i])&#123; </span><br><span class="line">        <span class="comment">// 遍历 i 位置前的数，比 i 位置小的数的位置 j 的严格单调递增的子序列的最大长度 + 1</span></span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 状态转移 取max</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(f[i], res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长上升子序列-II-nlogn"><a href="#最长上升子序列-II-nlogn" class="headerlink" title="最长上升子序列 II ($nlogn$)"></a>最长上升子序列 II ($nlogn$)</h3><p>思路：首先数组<code>arr</code>中存输入的数（原本的数），开辟一个数组f用来存结果，最终数组f的长度就是最终的答案；假如数组f现在存了数，当到了数组a的第i个位置时，首先判断$arr[i] &gt; f[cnt]$ ？ 若是大于则直接将这个数添加到数组f中，即$f[++cnt] = arr[i]$;这个操作时显然的。<br>当$arr[i] &lt;= f[cnt]$ 的时,我们就用$arr[i]$去替代数组f中的第一个大于等于$a[i]$的数，因为在整个过程中我们维护的数组f 是一个递增的数组，所以我们可以用二分查找在 $logn$ 的时间复杂的的情况下直接找到对应的位置，然后替换，即 $f[l] = arr[i]$。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> len = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;<span class="comment">//二分查找最大小于 arr[i] 数的位置 r</span></span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(q[mid] &lt; arr[i]) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    len = <span class="built_in">max</span>(len, r + <span class="number">1</span>);<span class="comment">//替换长度不变，添加 len = r + 1</span></span><br><span class="line">    q[r + <span class="number">1</span>] = arr[i]; <span class="comment">//替换或添加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。</p><blockquote><p>4 5<br>acbd<br>abedc</p><p>3</p></blockquote><p>状态： $f[i][j]$ 表示以 $a[i],b[j]$ 结尾的字符的最长公共子序列最大长度</p><ul><li>00 表示以 $a[i],b[j]$ 结尾的字符都不在最长公共子序列中</li><li>01 表示 $a[i]$ 不在, $b[j]$ 在</li><li>10 表示 $a[i]$ 在, $b[j]$ 不在</li><li>11 表示 $a[i],b[j]$ 都在，但 $a[i] == b[j]$</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j])f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>; </span><br><span class="line">        <span class="comment">// 第四种状态 最长公共子序列长度 + 1</span></span><br><span class="line">        <span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 其他状态表示 00 包含在 01 或 10 中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h3><p>题目：<a href="https://www.acwing.com/problem/content/901/">编辑距离</a></p><p>状态： $f[i][j]$ 表示以 $a[i]$ 变成 $b[j]$ 的最少操作次数</p><ul><li>删除: 删除$a[i]$ 使 $a[i - 1] = b[j]$： $f[i - 1][j] + 1$</li><li>添加: 在 $a[i]$ 后面添加 $b[j]$ 使 $a[i + 1] = b[j]$： $f[i][j - 1] + 1$</li><li>替换： 当$s[i] = t[j]，f[i - 1][j - 1]$ 否则$f[i - 1][j - 1] + 1$</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ )f[i][<span class="number">0</span>] = i; <span class="comment">//删除所有a[i]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++ )f[<span class="number">0</span>][i] = i; <span class="comment">//添加所有b[j]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )&#123;</span><br><span class="line">        f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">if</span>(s[i] == t[j])f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p>所有的区间dp问题枚举时，第一维通常是枚举区间长度，并且一般 <code>len = 1</code> 时用来初始化，枚举从 <code>len = 2</code> 开始；第二维枚举起点 <code>i</code> （右端点 <code>j</code>自动获得，<code>j = i + len - 1</code>）</p><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p>题目：<a href="https://www.acwing.com/problem/content/284/">石子合并</a></p><p>状态：$f[i][j]$ 表示区间 i 到 j 的合并的最小代价</p><ol><li><p>$i &lt; j$ 时，$f[i][j] = min(f[i][k] + f[k + 1][j] + s[j] − s[i − 1])$</p></li><li><p>$i = j$ 时， $f[i][i] = 0$（合并一堆石子代价为 0）</p></li></ol><p>通过区间 <code>2 ~ n</code> 划分，找出所有相邻两堆石子的最小质量<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++) s[i] += s[i - <span class="number">1</span>] + arr[i];<span class="comment">//前缀和，找出区间总和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len ++)&#123;<span class="comment">//划分区间大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i ++)&#123;</span><br><span class="line">            <span class="type">int</span> l = i,r = i + len - <span class="number">1</span>;<span class="comment">//划分左端点，右端点</span></span><br><span class="line">            f[l][r] = <span class="number">1e8</span>;<span class="comment">//找最小，初始化区间总和为无穷</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l; k &lt; r; k ++)&#123;<span class="comment">// k 为 两个区间分界点</span></span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><p>题目：<a href="https://www.acwing.com/problem/content/287/">没有上司的舞会</a></p><p>题意：员工不能不能和直接上司一起参加晚会</p><p>思路：通过树建立关系，从根结点dfs开始遍历所有子结点</p><p>状态：$f[i][j]$ 表示 <code>i</code> 结点, <code>j</code> 选取或不选取</p><ul><li>选取根结点： $f[u][1]$ 则其儿子结点不能再选</li><li>不选根节点： $f[u][0]$ 则只能选取儿子结点中的最大值</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> e[N], ne[N], w[N], h[N], idx;</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;<span class="comment">//链式前向星建树</span></span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = w[u]; <span class="comment">//赋予根结点权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);<span class="comment">//dfs从根结点开始遍历子结点</span></span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>], f[j][<span class="number">1</span>]);</span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];<span class="comment">//两种状态选取</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )cin &gt;&gt; w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(b , a);<span class="comment">// 建树</span></span><br><span class="line">        has_father[a] = <span class="literal">true</span>; <span class="comment">//确认 a 有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root])root ++;<span class="comment">//寻找根结点</span></span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]) &lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="状态压缩dp"><a href="#状态压缩dp" class="headerlink" title="状态压缩dp"></a>状态压缩dp</h2><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><p>题目：<a href="https://www.acwing.com/problem/content/293/">蒙德里安的梦想</a></p><p>思路：摆放方块的时候，先放横着的，再放竖着的。总方案数等于只放横着的小方块的合法方案数。</p><p>状态：f[i][j]<br> 表示已经将前 <code>i - 1</code> 列摆好，且从第 <code>i − 1</code> 列，伸出到第 <code>i</code> 列的状态是 <code>j</code> 的所有方案。其中 <code>j</code> 是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>, M = <span class="number">1</span>&lt;&lt; N;  </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M] ;<span class="comment">// 第一维表示列， 第二维表示所有可能的状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[M];  <span class="comment">//存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;int &gt; state[M];  //二维数组记录合法的状态</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">state</span>(M);  <span class="comment">//两种写法等价:二维数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m) &#123; <span class="comment">//读入n和m，并且不是两个0即合法输入就继续读入</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一部分：预处理1</span></span><br><span class="line">        <span class="comment">//对于每种状态，先预处理每列不能有奇数个连续的0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span> ;<span class="comment">//记录连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            <span class="type">bool</span> isValid = <span class="literal">true</span>; <span class="comment">// 某种状态没有奇数个连续的0则标记为true</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123; <span class="comment">//遍历这一列，从上到下</span></span><br><span class="line"></span><br><span class="line">                 <span class="keyword">if</span> ( (i &gt;&gt; j) &amp; <span class="number">1</span>) &#123;  </span><br><span class="line">                     <span class="comment">//i &gt;&gt; j位运算，表示i（i在此处是一种状态）的二进制数的第j位； </span></span><br><span class="line">                     <span class="comment">// &amp;1为判断该位是否为1，如果为1进入if</span></span><br><span class="line">                    <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>) &#123; </span><br><span class="line">                    <span class="comment">//这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法</span></span><br><span class="line">                        isValid =<span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; </span><br><span class="line"></span><br><span class="line">                    cnt = <span class="number">0</span>; <span class="comment">// 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。</span></span><br><span class="line">                    <span class="comment">//其实清不清零没有影响</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> cnt ++; <span class="comment">//否则的话该位还是0，则统计连续0的计数器++。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &amp; <span class="number">1</span>)  isValid = <span class="literal">false</span>; <span class="comment">//最下面的那一段判断一下连续的0的个数</span></span><br><span class="line"></span><br><span class="line">            st[i]  = isValid; <span class="comment">//状态i是否有奇数个连续的0的情况,输入到数组st中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二部分：预处理2</span></span><br><span class="line">        <span class="comment">// 经过上面每种状态 连续0的判断，已经筛掉一些状态。</span></span><br><span class="line">        <span class="comment">//下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j ++) &#123; <span class="comment">//对于第i列的所有状态</span></span><br><span class="line">            state[j].<span class="built_in">clear</span>(); <span class="comment">//清空上次操作遗留的状态，防止影响本次状态。</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="number">1</span> &lt;&lt; n); k ++) &#123; <span class="comment">//对于第i-1列所有状态</span></span><br><span class="line">                <span class="keyword">if</span> ((j &amp; k ) == <span class="number">0</span> &amp;&amp; st[ j | k]) </span><br><span class="line">                <span class="comment">// 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) </span></span><br><span class="line">                <span class="comment">//解释一下st[j | k] </span></span><br><span class="line">                <span class="comment">//已经知道st[]数组表示的是这一列没有连续奇数个0的情况，</span></span><br><span class="line">                <span class="comment">//我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，</span></span><br><span class="line">                <span class="comment">//还要考虑自己这一列（i-1列）横插到第i列的</span></span><br><span class="line">                <span class="comment">//比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，</span></span><br><span class="line">                <span class="comment">//那么合在第i-1列，到底有多少个1呢？</span></span><br><span class="line">                <span class="comment">//自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101</span></span><br><span class="line">                <span class="comment">//这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的</span></span><br><span class="line"></span><br><span class="line">                    state[j].<span class="built_in">push_back</span>(k);  </span><br><span class="line">                    <span class="comment">//二维数组state[j]表示第j行， </span></span><br><span class="line">                    <span class="comment">//j表示 第i列“真正”可行的状态，</span></span><br><span class="line">                    <span class="comment">//如果第i-1列的状态k和j不冲突则压入state数组中的第j行。</span></span><br><span class="line">                    <span class="comment">//“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三部分：dp开始</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);  </span><br><span class="line">        <span class="comment">//全部初始化为0，因为是连续读入，这里是一个清空操作。</span></span><br><span class="line">        <span class="comment">//类似上面的state[j].clear()</span></span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;<span class="comment">// 这里需要回忆状态表示的定义</span></span><br><span class="line">        <span class="comment">//按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。</span></span><br><span class="line">        <span class="comment">//首先，这里没有-1列，最少也是0列。</span></span><br><span class="line">        <span class="comment">//其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123; <span class="comment">//遍历每一列:第i列合法范围是(0~m-1列)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span>&lt;&lt;n); j ++) &#123;  <span class="comment">//遍历当前列（第i列）所有状态j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> k : state[j])    <span class="comment">// 遍历第i-1列的状态k，如果“真正”可行，就转移</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];    <span class="comment">// 当前列的方案数就等于之前的第i-1列所有状态k的累加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最后答案是什么呢？</span></span><br><span class="line">        <span class="comment">//f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。</span></span><br><span class="line">        <span class="comment">//即整个棋盘处理完的方案数</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h3><p>题目：<a href="https://www.acwing.com/problem/content/93/">最短Hamilton路径</a></p><p>思路：用二进制来表示要走的所以情况的路径,这里用 <code>i</code> 来代替<br>例如走 <code>0,1,2,4</code> 这三个点,则表示为:<code>10111</code>;<br>走 <code>0,2,3</code> 这三个点: <code>1101</code>;  </p><p>假设: 一共有七个点,用 <code>0,1,2,3,4,5,6</code> 来表示,那么先假设终点就是 <code>5</code>,在这里我们再假设还没有走到 <code>5</code> 这个点,且走到的终点是 <code>4</code>,那么有以下六种情况:<br>first: <code>0–&gt;1–&gt;2–&gt;3–&gt;4</code> 距离:<code>21</code><br>second: <code>0–&gt;1–&gt;3–&gt;2–&gt;4</code> 距离:<code>23</code><br>third: <code>0–&gt;2–&gt;1–&gt;3–&gt;4</code> 距离:<code>17</code><br>fourth: <code>0–&gt;2–&gt;3–&gt;1–&gt;4</code> 距离:<code>20</code><br>fifth: <code>0–&gt;3–&gt;1–&gt;2–&gt;4</code> 距离:<code>15</code><br>sixth: <code>0–&gt;3–&gt;2–&gt;1–&gt;4</code> 距离:<code>18</code>  </p><p>状态：$f[i][j]$ 所有从 <code>0</code> 走到 <code>j</code>,走过的所有点的情况是i的所有路径最短距离<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>, M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            cin &gt;&gt; w[i][j];</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//0 到 0 距离为 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i ++ )<span class="comment">// 遍历每一种状态情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )<span class="comment">// 遍历每个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">// 看 j 号点是否存在</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k ++ ) <span class="comment">// 找出以 k 为终点的路径</span></span><br><span class="line">                    <span class="keyword">if</span>(i &gt;&gt; k &amp; <span class="number">1</span>)<span class="comment">// 看终点是否存在</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);<span class="comment">//算出以 k 为终点的路径(不包括 j 号点) + k 到 j 的唯一路径</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="数位dp"><a href="#数位dp" class="headerlink" title="数位dp"></a>数位dp</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><p>题目：<a href="https://www.acwing.com/problem/content/340/">计数问题</a></p><p>思路：<img src="https://cdn.acwing.com/media/article/image/2023/08/10/229560_06a5c73137-%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA.png" alt=""></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getn</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 获取数字的位数</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x) x /= <span class="number">10</span>, res ++;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i)</span></span>&#123;<span class="comment">//找出0 ~ n 数字 i 的个数</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">getn</span>(n), res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= len; j ++)&#123; <span class="comment">//遍历数字每一位数</span></span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">pow</span>(<span class="number">10</span>, len - j), l = n / p / <span class="number">10</span>, di = n / p % <span class="number">10</span>, r = n % p;</span><br><span class="line">    <span class="comment">/* 找出以每一位数字 di 为中点的左部分 l 和 右部分 r 的数字</span></span><br><span class="line"><span class="comment">        例如： abcdefg</span></span><br><span class="line"><span class="comment">        l = abc , di = d , r = efg    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(i) res += l * p;<span class="comment">//分状况讨论 j 位上 数字 i 的所有情况</span></span><br><span class="line">    <span class="keyword">else</span> res +=(l - <span class="number">1</span>) * p;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(di == i) res += r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(di &gt; i) res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b, a || b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b)<span class="built_in">swap</span>(a, b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i ++)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b, i) - <span class="built_in">count</span>(a - <span class="number">1</span>, i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;     </span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p>题目：<a href="https://www.acwing.com/problem/content/903/">滑雪</a></p><p>题意：一个人从滑雪场中的某个区域内出发，每次可以向上下左右任意一个方向滑动一个单位距离。<br>当然，一个人能够滑动到某相邻区域的前提是该区域的高度低于自己目前所在区域的高度。</p><p>状态：$f[i][j]$ 从位置<code>（i，j）</code>走过的最多区域<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n, m, f[N][N], g[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[x][y];<span class="comment">// 引用别名，v 变化 f[i][j] 变化</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>)<span class="keyword">return</span> v;<span class="comment">// 如果走过直接返回 ，减少重复计算步骤</span></span><br><span class="line">    v = <span class="number">1</span>;<span class="comment">//初始化每个点为 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123; <span class="comment">//搜索四个方向</span></span><br><span class="line">        <span class="type">int</span> xx = dx[i] + x;</span><br><span class="line">        <span class="type">int</span> yy = dy[i] + y;</span><br><span class="line">        <span class="keyword">if</span>(xx &lt;= n &amp;&amp; xx &gt;= <span class="number">1</span> &amp;&amp; yy &lt;= m &amp;&amp; yy &gt;= <span class="number">1</span> &amp;&amp; g[xx][yy] &lt; g[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(v, <span class="built_in">dp</span>(xx, yy) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dp</span>(i, j));<span class="comment">//遍历每一个位置</span></span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></p><h2 id="计数类dp"><a href="#计数类dp" class="headerlink" title="计数类dp"></a>计数类dp</h2><h3 id="整数划分"><a href="#整数划分" class="headerlink" title="整数划分"></a>整数划分</h3><p>题目：<a href="https://www.acwing.com/problem/content/902/">整数划分</a></p><p>思路：把 <code>1,2,3, … n</code> 分别看做<code>n</code>个物体的体积，这<code>n</code>个物体均无使用次数限制，问恰好能装满总体积为<code>n</code>的背包的总方案数（完全背包问题变形）</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j ++)&#123;</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划（背包问题）</title>
      <link href="/2023/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%89/"/>
      <url>/2023/08/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p>每个物品最多取一次</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n;i ++ )&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; w; <span class="comment">//边输入边处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j -- )&#123; <span class="comment">//容量必须大于可选体积</span></span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j],f[j - v] + w);</span><br><span class="line">        <span class="comment">//f[i][j] = max(f[i - 1][j], f[i - 1][j - v] + w) j 正序</span></span><br><span class="line">        <span class="comment">//f[j]不选，f[j-v]+w 选择 取两者最大</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*关于一维为什么j要逆序。</span></span><br><span class="line"><span class="comment">    因为正序f[j]的可能取到i(本轮)轮的f[j]而不是i-1轮的。</span></span><br><span class="line"><span class="comment">    如果j正序：</span></span><br><span class="line"><span class="comment">    在i轮，在j&gt;=v的条件下v=4,w=5</span></span><br><span class="line"><span class="comment">    f[j](j取4,5,6,7,  8)</span></span><br><span class="line"><span class="comment">    =max(f[j],f[j-v]( j-v 取0,1,2,3, 4(而这个4，则会计算f[i][4],而不是f[i-1][4]) )+w);</span></span><br><span class="line"><span class="comment">    如果j逆序：</span></span><br><span class="line"><span class="comment">    在i轮，在j&gt;=v的条件下v=4,w=5</span></span><br><span class="line"><span class="comment">    不会出现f[i][j-v]情况，因为f[j-v]一直是第一次出现。 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>每个物品可无限取</p><p>$f[i,j]=max(f[i−1,j],f[i−1,j−v]+w,f[i−1,j−2v]+2w,f[i−1,j−3v]+3w,…..)$</p><p>$f[i,j−v]=max(       f[i−1,j−v],f[i−1,j−2v]+w,f[i−1,j−3v]+2w,…..)$</p><p>通过上述替换，可以得到 f[i][j]=max(f[i−1][j],f[i][j−v]+w)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = v;j &lt;= m; j++)&#123;<span class="comment">//这里j=v,是因为要保证j-v&gt;=0</span></span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v] + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*上一篇代码中，解释过，逆序是为了保证更新当前状态时，用到的状态是上一轮的状态，保证每个物品只有一次或零次;</span></span><br><span class="line"><span class="comment">在这里，因为每个物品可以取任意多次，所以不再强求用上一轮的状态，即本轮放过的物品，在后面还可以再放;*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多重背包I"><a href="#多重背包I" class="headerlink" title="多重背包I"></a>多重背包I</h3><p>每个物品最多取 s 次($O(n^3)$)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">二维写法</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; k * v &lt;= j; k ++)&#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v * k] + w * k); </span><br><span class="line">            <span class="comment">// k = 0 已经包含了f [ i ] [ j ] = f [ i - 1 ] [ j ] 也就是不选 i 这个操作，</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">一维写法</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)&#123;</span><br><span class="line">    cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v; j --)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s &amp;&amp; k * v &lt;= j; k ++)&#123;</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v * k] + w * k); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多重背包II"><a href="#多重背包II" class="headerlink" title="多重背包II"></a>多重背包II</h3><p>每个物品最多取 s 次($O(n m logs)$)</p><p>$f[i,j]  = max(f[i−1,j],f[i−1,j−v]+w,f[i−1,j−2v]+2w,…..f[i−1,j−Sv]+Sw)$</p><p>$f[i,j−v] = max(f[i−1,j−v],f[i−1,j−2v]+w,…..f[i−1,j−Sv]+(S−1)w,f[i−1,j−(S+1)v]+Sw)$</p><p>因为有次数 S 和 容量 j 的限制，最后一项并不能确定是否能装满，无法消除。</p><p>关于为什么不能像完全背包一样优化：关键在于完全背包问题仅有 v[i] <em> k &lt;= j 的限制，所以f(i, j) 与 f(i, j - v) 的最后一项都应满足背包能够装得下，f(i, j - v)由于容量上限限制，故两者的最后一项是相同的；而在多重背包中，还需要满足 k &lt;= s[i]，当 s[i] </em> v[i] &lt;= j - v 时，可以将所有的物品 i 均放入也不会超出容量限制，故 f(i, j - v) 将会比 f(i, j)多一项。</p><p>水果店里有 40 个苹果，小明计划购买 n  ( 1 ≤ n ≤ 40 ) 个苹果，试问如何让小明尽可能快速地完成购买？<br>一个显而易见的暴力做法是，让小明一个个拿（单位是个），但效率过于低下。事实上，店员可事先准备好 6  个箱子，每个箱子中的苹果数量分别为[ 1 , 2 , 4 , 8 , 16 , 9 ]，再让小明按箱子拿（单位是箱子），无论小明计划购买多少个，他最多只需要拿 6 次，而在暴力做法中，小明最多需要拿 40 次。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">二进制优化</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="type">int</span> a, b, s;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= s)&#123; <span class="comment">//二进制分组转化成01背包</span></span><br><span class="line">        cnt ++ ;</span><br><span class="line">        v[cnt] = a * k;</span><br><span class="line">        w[cnt] = b * k;</span><br><span class="line">        s -= k;</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        cnt ++ ;</span><br><span class="line">        v[cnt] = a * s;</span><br><span class="line">        w[cnt] = b * s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">n = cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= v[i]; j -- )&#123;</span><br><span class="line">        f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>每组物品有若干个，同一组内的物品最多只能选一个。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++ )&#123;</span><br><span class="line">        cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;<span class="comment">//01背包类似</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j -- )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; s[i]; k ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i][k])f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序合集(上)</title>
      <link href="/2023/08/12/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86-%E4%B8%8A/"/>
      <url>/2023/08/12/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="常见排序"><a href="#常见排序" class="headerlink" title="常见排序"></a>常见排序</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt=""><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123; </span><br><span class="line">        if_swap = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j + <span class="number">1</span>],arr[j]);</span><br><span class="line">                if_swap = <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(if_swap==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果没有发生交换，说明已经是有序序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。<br><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> minx=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minx]&gt;arr[j])&#123;</span><br><span class="line">                minx=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minx!=i)<span class="built_in">swap</span>(arr[i],arr[minx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ol><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。</li><li>重复上述过程直到最后一个元素被插入有序子数组中。<br><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos=i;</span><br><span class="line">        <span class="type">int</span> value=arr[i];</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;<span class="number">0</span>&amp;&amp;arr[pos<span class="number">-1</span>]&gt;value)&#123;<span class="comment">//向前找比自己大的最后一个位置插入</span></span><br><span class="line">            arr[pos]=arr[pos<span class="number">-1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos]=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ol><li>先使每个子序列有序，再使子序列段间有序</li><li>将已有序的子序列合并，得到完全有序的序列<br><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,l,mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,mid+<span class="number">1</span>,r);<span class="comment">//分治思想，递归</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp[r-l+<span class="number">1</span>],k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<span class="comment">//合并子序列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])temp[k++]=arr[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=arr[j++];<span class="comment">//二路归并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)temp[k++]=arr[j++];<span class="comment">//剩余序列直接加上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++)arr[i]=temp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li>从数列中挑出一个元素，称为”基准”，</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=i<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x=arr[(l+r)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(arr[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(arr[j]&gt;x);<span class="comment">//大的放前面，小的放后面</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,l,j);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,j+<span class="number">1</span>,r); <span class="comment">//分治递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一种特殊的完全二叉树。</p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= n &amp;&amp; arr[<span class="number">2</span> * u] &lt; arr[t]) t = <span class="number">2</span> * u;<span class="comment">//有左儿子，并且左儿子比t节点的值小，更新t</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= n &amp;&amp; arr[<span class="number">2</span> * u + <span class="number">1</span>] &lt; arr[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;<span class="comment">//有右儿子，并且右儿子比t节点的值小，更新t</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[u],arr[t]);<span class="comment">//交换节点</span></span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)<span class="built_in">down</span>(i);<span class="comment">//从第一个非叶节点开始，从右到左，从下到上处理每个节点</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cout&lt;&lt;arr[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">1</span>],arr[n]);</span><br><span class="line">        n--;<span class="comment">//输出第一个元素，再交换到最后，再删去</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);<span class="comment">//递归处理左右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol><li>选择一个增量序列$t_1$，$t_2$，…，$t_k$，其中$t_i&gt;t_j$，$t_k=1$；</li><li>按增量序列个数k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br><img src="https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> delta = n /<span class="number">2</span>; delta&gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;   <span class="comment">//确定增量                          </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=delta; i&lt;n; i++)&#123; <span class="comment">// 进行 n-delta 次排序            </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=delta &amp;&amp; arr[j]&lt;arr[j-delta]; j-=delta)&#123; </span><br><span class="line">                <span class="built_in">swap</span>(arr[j-delta],arr[j]);<span class="comment">//交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>参考文章：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大排序算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathjax语法</title>
      <link href="/2023/08/11/mathjax%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/08/11/mathjax%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mathjax-语法"><a href="#Mathjax-语法" class="headerlink" title="Mathjax 语法"></a>Mathjax 语法</h1><h3 id="MathJax简介"><a href="#MathJax简介" class="headerlink" title="MathJax简介"></a>MathJax简介</h3><p><code>MathJax</code>是一款运行在浏览器中的开源数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片，支持 <code>Markdown</code> 编辑，可解析 <code>LateX</code> 。对于在文本编制中，规范数学数学公式非常的 nice。</p><h3 id="公式显示"><a href="#公式显示" class="headerlink" title="公式显示"></a>公式显示</h3><ol><li><p>行类显示</p><pre><code> $....$</code></pre></li><li><p>块内显示</p><pre><code> $$....$$</code></pre></li></ol><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p><img src="https://pic1.zhimg.com/80/v2-aff7c3f10829d12e145d4a88835912c8_1440w.webp" alt="图片" title="字母表"></p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>上标 ^ , 下表 _ </p><pre><code>x_2^4 log_2^4  x^&#123;2^5&#125;</code></pre><p>$x_i^2$ , $log_24$ , $x^{2^5}$</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><pre><code>1. 小括号与方括号：使用原始的()，[]即可，(2+3)[4+4]</code></pre><script type="math/tex; mode=display">(2+3)[4+4]</script><pre><code>2. 大括号：由于大括号&#123;&#125;被用来分组，因此需要使用\&#123;和\&#125;表示大括号，也可以使用\lbrace和\rbrace来表示。如\&#123;a*b\&#125;: ，\lbrace a*b \rbrace</code></pre><script type="math/tex; mode=display">\{a*b\}</script><pre><code>3. 尖括号：使用\langle和\rangle表示左尖括号和右尖括号。如\langle x \rangle : </code></pre><script type="math/tex; mode=display"><a,b></script><pre><code>4. 上取整：使用\lceil和\rceil表示。如\lceil x \rceil： </code></pre><script type="math/tex; mode=display">\lceil4.5\rceil</script><pre><code>5. 下取整：使用\lfloor和\rfloor表示。如\lfloor x \rfloor： </code></pre><script type="math/tex; mode=display">\lfloor4.5\rfloor</script><h3 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h3><pre><code>1. \sum用来表示求和符号，其下标表示求和下限，上标表示上限。如\sum_1^n: </code></pre><script type="math/tex; mode=display">\sum_1^n</script><pre><code>2. \int用来表示积分符号，同样地，其上下标表示积分的上下限。如\int_1^\infty: </code></pre><script type="math/tex; mode=display">\int_1^\infty</script><pre><code>3. 与此类似的符号还有：\prod, \bigcup, \bigcap ,\iint:</code></pre><p>$\prod$ , $\bigcup$ , $\bigcap$ ,  $\iint$</p><h3 id="分式和根式"><a href="#分式和根式" class="headerlink" title="分式和根式"></a>分式和根式</h3><pre><code>(1)使用\frac ab , \frac作用于其后的两个组a , b ，结果为 。如果你的分子或分母不是单个字符，请使用&#123;...&#125;来分组。如：\frac a&#123;bc&#125;</code></pre><script type="math/tex; mode=display">\frac a{bc}</script><pre><code>(2)使用\over来分隔一个组的前后两部分，如&#123;a+1 \over b+1&#125;: </code></pre><script type="math/tex; mode=display">a+1 \over b+1</script><pre><code>(3)根式使用\sqrt表示，如：\sqrt[4]&#123;\frac xy&#125; : </code></pre><script type="math/tex; mode=display">\sqrt[4]{\frac xy}</script><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre><code>(1)使用\mathbb或\Bbb显示黑板粗体字，此字体经常用来表示实数、整数、有理数、复数。如 </code></pre><script type="math/tex; mode=display">\mathbb{R,Z,Q,C}</script><pre><code>(2)使用\mathbf显示黑体字，如</code></pre><script type="math/tex; mode=display">\mathbf{R,Z,Q,C}</script><pre><code>(3)使用\mathtt显示打印机字体，如</code></pre><script type="math/tex; mode=display">\mathtt{R,Z,Q,C}</script><pre><code>(4)使用\mathrm显示罗马字体，如</code></pre><script type="math/tex; mode=display">\mathrm{R,Z,Q,C,a,b,c,d}</script><pre><code>(5)使用\mathscr显示手写体，如</code></pre><script type="math/tex; mode=display">\mathscr{R,Z,Q,C}</script><pre><code>(6)使用\mathfrak显示Fraktur字母（一种德国字体），如</code></pre><script type="math/tex; mode=display">\mathfrak{R,Z,Q,C}</script><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><pre><code>(1)常见的三角函数，如 sin\; x,arctan\; x,lim_&#123;1\to\infty&#125;</code></pre><script type="math/tex; mode=display">sin\; x,arctan\;x,lim_{1\to\infty}</script><pre><code>(2)比较运算符：\lt \gt \le \ge \neq ,可以在这些运算符前面加上\not，如\not\lt : </code></pre><script type="math/tex; mode=display">\lt \gt \le \ge \neq , \not\lt</script><pre><code>(3)\times \div \pm \mp 表示： ，\cdot表示居中的点，x \cdot y ： </code></pre><script type="math/tex; mode=display">\times \div \pm \mp,x \cdot y</script><pre><code>(4)集合关系与运算：\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing : </code></pre><script type="math/tex; mode=display">\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing</script><pre><code>(5)表示排列使用\binom&#123;n+1&#125;&#123;2k&#125;或&#123;n+1 \choose 2k&#125;</code></pre><script type="math/tex; mode=display">\binom{n+1}{2k}</script><pre><code>(6)箭头：\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto: :</code></pre><script type="math/tex; mode=display">\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto</script><pre><code>(7)逻辑运算符：\land \lor \lnot \forall \exists \top \bot \vdash \vDash： </code></pre><script type="math/tex; mode=display">\land \lor \lnot \forall \exists \top \bot \vdash \vDash</script><pre><code>(8)\star \ast \oplus \circ \bullet : </code></pre><script type="math/tex; mode=display">\star \ast \oplus \circ \bullet</script><pre><code>(9)\approx \sim \cong \equiv \prec : </code></pre><script type="math/tex; mode=display">\approx \sim \cong \equiv \prec</script><pre><code>(10)\infty \aleph_o \nabla \partial \Im \Re : </code></pre><script type="math/tex; mode=display">\infty \aleph_o \nabla \partial \Im \Re</script><pre><code>(11)模运算 \pmode , 如 a \equiv b \pmod n : </code></pre><script type="math/tex; mode=display">a \equiv b \pmod n</script><pre><code>(12)\ldots与\cdots，其区别是dots的位置不同，ldots位置稍低，cdots位置居中</code></pre><script type="math/tex; mode=display">\ldots与\cdots</script><pre><code>(13)一些希腊字母具有变体形式，如\epsilon \varepsilon : ，\phi \varphi : </code></pre><script type="math/tex; mode=display">\epsilon \varepsilon，\phi \varphi</script><h3 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h3><pre><code>可以通过在ab间加入\,增加些许间隙，\;增加较宽间隙，\quad与\qquad会增加更大的间隙，如 ：a \quad b</code></pre><script type="math/tex; mode=display">a \quad b</script><h3 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a>顶部符号</h3><pre><code>(1)对于单字符，\hat x: </code></pre><script type="math/tex; mode=display">\hat x</script><pre><code>(2)对于多字符，\widehat &#123;xy&#125;: </code></pre><script type="math/tex; mode=display">\widehat {xy}</script><pre><code>(3)类似的还有 \overline , \vec , \overrightarrow , \dot , \ddot : </code></pre><script type="math/tex; mode=display">\overline {xyz}, \vec x, \overrightarrow x, \dot x, \ddot x</script><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><pre><code>$$\begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \end&#123;matrix&#125;$$</code></pre><script type="math/tex; mode=display">\begin{matrix} 1 & x & x^2 \\ 1 & y & y^2 \\ 1 & z & z^2 \end{matrix}</script><pre><code>替换\begin&#123;matrix&#125;...\end&#123;matrix&#125;中的matrix为pmatrix , bmatrix , Bmatrix , vmatrix , Vmatrix.</code></pre><script type="math/tex; mode=display">\begin{pmatrix} 1 & x \\ 1 & y \end{pmatrix},\begin{bmatrix} 1 & x \\ 1 & y \end{bmatrix},\begin{Bmatrix} 1 & x \\ 1 & y \end{Bmatrix},\begin{vmatrix} 1 & x \\ 1 & y \end{vmatrix},\begin{Vmatrix} 1 & x \\ 1 & y \end{Vmatrix}</script><p>想要更加深入学 <code>Mathjax</code> 到 <a href="https://zhuanlan.zhihu.com/p/568747716">这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/08/10/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/08/10/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>建站的第一件事就是先去学习了一下 <code>Markdown</code> 语法 , 方便对于博客的编写 。  </p><p> <code>Markdown</code> 对于文本的编辑与 <code>HTML</code> 相比可以说是非常的通俗易懂 , 下面是我对与 <code>Markdown</code> 常用语法使用的一些总结 。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p> # ~ ######  一到六级标题</p><p># 一级标题</p><p>以此类推 </p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在一行的末尾添加两个或多个空格 ，然后按回车键 , 即可创建一个换行 。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>斜体： *斜体* ，  效果：<em>斜体</em></p><p>粗体： **粗体** ，  效果：<strong>粗体</strong></p><p>粗体+斜体：***粗体+斜体 *** ， 效果：<strong><em>粗体+斜体</em></strong></p><p>删除线  ~~删除线~~ ，效果：  <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在段落前添加一个 &gt; 符号 ，可嵌套其他元素 。</p><p>> this is my blog</p><blockquote><p>this is my blog</p><blockquote><ul><li>welcome!</li></ul></blockquote></blockquote><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ol><li><p>有序列表 ，可嵌套</p><ol><li>标题<ol><li>一级标题</li></ol></li><li>换行<ol><li>br</li></ol></li></ol></li></ol><ol><li><p>无序列表</p><p> - title<br> - br</p><ul><li>title</li><li>title</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>`markdown` ，<code>markdown</code></p><p>``using namespace `std` `` ，<code>using namespace `std` </code> </p><p>代码块：将代码块的每一行缩进至少四个空格或一个制表符。</p><pre><code>typedef struct node&#123;    int x = x;&#125;</code></pre><p>代码块围栏：</p><p>``` C++</p><p> 代码围栏区域 </p><p>```<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>超链接：</p><p>[超链接显示名](超链接地址 “超链接title”)</p><p><a href="https://godzillamonste.github.io" title="myblog">Jia</a></p><p>网站链接：</p><p>&lt; * <a href="https://markdown.com.cn">https://markdown.com.cn</a> * ></p><p>&lt; <em><a href="https://markdown.com.cn">https://markdown.com.cn</a></em> &gt;</p><p>可内嵌格式化链接，粗体，斜体，代码</p><p>图片链接：</p><p>![图片alt](图片链接 “图片title”)</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>（—-）创建每列的标题，并使用管道（|）分隔每列。</p><p>| Syntax      | Description |<br>| —————- | —————- |<br>| Header      | Title       |<br>| Paragraph   | Text        |</p><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>图形化表格制作：<a href="https://www.tablesgenerator.com/markdown_tables"> markdown 表格生成器 </a></p><hr><p>文章参考：<a href="https://markdown.com.cn"> markdown 官方文档 </a> </p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
