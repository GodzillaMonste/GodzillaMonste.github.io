<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>排序合集(上)</title>
      <link href="/2023/08/12/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86-%E4%B8%8A/"/>
      <url>/2023/08/12/%E6%8E%92%E5%BA%8F%E5%90%88%E9%9B%86-%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="常见排序"><a href="#常见排序" class="headerlink" title="常见排序"></a>常见排序</h1><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt=""></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ol><p><img src="https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.webp" alt=""><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123; </span><br><span class="line">        if_swap = <span class="literal">false</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[j + <span class="number">1</span>],arr[j]);</span><br><span class="line">                if_swap = <span class="literal">true</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(if_swap==<span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//如果没有发生交换，说明已经是有序序列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ol><li>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。<br><img src="https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> minx=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[minx]&gt;arr[j])&#123;</span><br><span class="line">                minx=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minx!=i)<span class="built_in">swap</span>(arr[i],arr[minx]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><ol><li>把待排序的数组分成已排序和未排序两部分，初始的时候把第一个元素认为是已排好序的。</li><li>从第二个元素开始，在已排好序的子数组中寻找到该元素合适的位置并插入该位置。</li><li>重复上述过程直到最后一个元素被插入有序子数组中。<br><img src="https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(<span class="type">int</span> arr[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> pos=i;</span><br><span class="line">        <span class="type">int</span> value=arr[i];</span><br><span class="line">        <span class="keyword">while</span>(pos&gt;<span class="number">0</span>&amp;&amp;arr[pos<span class="number">-1</span>]&gt;value)&#123;<span class="comment">//向前找比自己大的最后一个位置插入</span></span><br><span class="line">            arr[pos]=arr[pos<span class="number">-1</span>];</span><br><span class="line">            pos--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[pos]=value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ol><li>先使每个子序列有序，再使子序列段间有序</li><li>将已有序的子序列合并，得到完全有序的序列<br><img src="https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,l,mid);</span><br><span class="line">    <span class="built_in">mergeSort</span>(arr,mid+<span class="number">1</span>,r);<span class="comment">//分治思想，递归</span></span><br><span class="line">    <span class="type">int</span> i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> temp[r-l+<span class="number">1</span>],k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)&#123;<span class="comment">//合并子序列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;=arr[j])temp[k++]=arr[i++];</span><br><span class="line">        <span class="keyword">else</span> temp[k++]=arr[j++];<span class="comment">//二路归并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)temp[k++]=arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)temp[k++]=arr[j++];<span class="comment">//剩余序列直接加上</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l,k=<span class="number">0</span>;i&lt;=r;i++,k++)arr[i]=temp[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><ol><li>从数列中挑出一个元素，称为”基准”，</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。</li><li>递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> i=i<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> x=arr[(l+r)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span>&#123;i++;&#125;<span class="keyword">while</span>(arr[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span>&#123;j--;&#125;<span class="keyword">while</span>(arr[j]&gt;x);<span class="comment">//大的放前面，小的放后面</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(arr[i],arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,l,j);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr,j+<span class="number">1</span>,r); <span class="comment">//分治递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>堆是一种特殊的完全二叉树。</p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= n &amp;&amp; arr[<span class="number">2</span> * u] &lt; arr[t]) t = <span class="number">2</span> * u;<span class="comment">//有左儿子，并且左儿子比t节点的值小，更新t</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= n &amp;&amp; arr[<span class="number">2</span> * u + <span class="number">1</span>] &lt; arr[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;<span class="comment">//有右儿子，并且右儿子比t节点的值小，更新t</span></span><br><span class="line">    <span class="keyword">if</span>(u != t)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[u],arr[t]);<span class="comment">//交换节点</span></span><br><span class="line">        <span class="built_in">down</span>(t);<span class="comment">//递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;=<span class="number">1</span>;i--)<span class="built_in">down</span>(i);<span class="comment">//从第一个非叶节点开始，从右到左，从下到上处理每个节点</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cout&lt;&lt;arr[<span class="number">1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">1</span>],arr[n]);</span><br><span class="line">        n--;<span class="comment">//输出第一个元素，再交换到最后，再删去</span></span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);<span class="comment">//递归处理左右子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ol><li>选择一个增量序列$t_1$，$t_2$，…，$t_k$，其中$t_i&gt;t_j$，$t_k=1$；</li><li>按增量序列个数k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量$t_i$，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br><img src="https://pic3.zhimg.com/v2-f14e4169ff39bad42c3dd6c385ad9c72_b.webp" alt=""><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> delta = n /<span class="number">2</span>; delta&gt;=<span class="number">1</span>; delta/=<span class="number">2</span>)&#123;   <span class="comment">//确定增量                          </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=delta; i&lt;n; i++)&#123; <span class="comment">// 进行 n-delta 次排序            </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&gt;=delta &amp;&amp; arr[j]&lt;arr[j-delta]; j-=delta)&#123; </span><br><span class="line">                <span class="built_in">swap</span>(arr[j-delta],arr[j]);<span class="comment">//交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>参考文章：<a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大排序算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mathjax语法</title>
      <link href="/2023/08/11/mathjax%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/08/11/mathjax%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Mathjax-语法"><a href="#Mathjax-语法" class="headerlink" title="Mathjax 语法"></a>Mathjax 语法</h1><h3 id="MathJax简介"><a href="#MathJax简介" class="headerlink" title="MathJax简介"></a>MathJax简介</h3><p><code>MathJax</code>是一款运行在浏览器中的开源数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片，支持 <code>Markdown</code> 编辑，可解析 <code>LateX</code> 。对于在文本编制中，规范数学数学公式非常的 nice。</p><h3 id="公式显示"><a href="#公式显示" class="headerlink" title="公式显示"></a>公式显示</h3><ol><li><p>行类显示</p><pre><code> $....$</code></pre></li><li><p>块内显示</p><pre><code> $$....$$</code></pre></li></ol><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p><img src="https://pic1.zhimg.com/80/v2-aff7c3f10829d12e145d4a88835912c8_1440w.webp" alt="图片" title="字母表"></p><h3 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h3><p>上标 ^ , 下表 _ </p><pre><code>x_2^4 log_2^4  x^&#123;2^5&#125;</code></pre><p>$x_i^2$ , $log_24$ , $x^{2^5}$</p><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><pre><code>1. 小括号与方括号：使用原始的()，[]即可，(2+3)[4+4]</code></pre><script type="math/tex; mode=display">(2+3)[4+4]</script><pre><code>2. 大括号：由于大括号&#123;&#125;被用来分组，因此需要使用\&#123;和\&#125;表示大括号，也可以使用\lbrace和\rbrace来表示。如\&#123;a*b\&#125;: ，\lbrace a*b \rbrace</code></pre><script type="math/tex; mode=display">\{a*b\}</script><pre><code>3. 尖括号：使用\langle和\rangle表示左尖括号和右尖括号。如\langle x \rangle : </code></pre><script type="math/tex; mode=display"><a,b></script><pre><code>4. 上取整：使用\lceil和\rceil表示。如\lceil x \rceil： </code></pre><script type="math/tex; mode=display">\lceil4.5\rceil</script><pre><code>5. 下取整：使用\lfloor和\rfloor表示。如\lfloor x \rfloor： </code></pre><script type="math/tex; mode=display">\lfloor4.5\rfloor</script><h3 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h3><pre><code>1. \sum用来表示求和符号，其下标表示求和下限，上标表示上限。如\sum_1^n: </code></pre><script type="math/tex; mode=display">\sum_1^n</script><pre><code>2. \int用来表示积分符号，同样地，其上下标表示积分的上下限。如\int_1^\infty: </code></pre><script type="math/tex; mode=display">\int_1^\infty</script><pre><code>3. 与此类似的符号还有：\prod, \bigcup, \bigcap ,\iint:</code></pre><p>$\prod$ , $\bigcup$ , $\bigcap$ ,  $\iint$</p><h3 id="分式和根式"><a href="#分式和根式" class="headerlink" title="分式和根式"></a>分式和根式</h3><pre><code>(1)使用\frac ab , \frac作用于其后的两个组a , b ，结果为 。如果你的分子或分母不是单个字符，请使用&#123;...&#125;来分组。如：\frac a&#123;bc&#125;</code></pre><script type="math/tex; mode=display">\frac a{bc}</script><pre><code>(2)使用\over来分隔一个组的前后两部分，如&#123;a+1 \over b+1&#125;: </code></pre><script type="math/tex; mode=display">a+1 \over b+1</script><pre><code>(3)根式使用\sqrt表示，如：\sqrt[4]&#123;\frac xy&#125; : </code></pre><script type="math/tex; mode=display">\sqrt[4]{\frac xy}</script><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><pre><code>(1)使用\mathbb或\Bbb显示黑板粗体字，此字体经常用来表示实数、整数、有理数、复数。如 </code></pre><script type="math/tex; mode=display">\mathbb{R,Z,Q,C}</script><pre><code>(2)使用\mathbf显示黑体字，如</code></pre><script type="math/tex; mode=display">\mathbf{R,Z,Q,C}</script><pre><code>(3)使用\mathtt显示打印机字体，如</code></pre><script type="math/tex; mode=display">\mathtt{R,Z,Q,C}</script><pre><code>(4)使用\mathrm显示罗马字体，如</code></pre><script type="math/tex; mode=display">\mathrm{R,Z,Q,C,a,b,c,d}</script><pre><code>(5)使用\mathscr显示手写体，如</code></pre><script type="math/tex; mode=display">\mathscr{R,Z,Q,C}</script><pre><code>(6)使用\mathfrak显示Fraktur字母（一种德国字体），如</code></pre><script type="math/tex; mode=display">\mathfrak{R,Z,Q,C}</script><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><pre><code>(1)常见的三角函数，如 sin\; x,arctan\; x,lim_&#123;1\to\infty&#125;</code></pre><script type="math/tex; mode=display">sin\; x,arctan\;x,lim_{1\to\infty}</script><pre><code>(2)比较运算符：\lt \gt \le \ge \neq ,可以在这些运算符前面加上\not，如\not\lt : </code></pre><script type="math/tex; mode=display">\lt \gt \le \ge \neq , \not\lt</script><pre><code>(3)\times \div \pm \mp 表示： ，\cdot表示居中的点，x \cdot y ： </code></pre><script type="math/tex; mode=display">\times \div \pm \mp,x \cdot y</script><pre><code>(4)集合关系与运算：\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing : </code></pre><script type="math/tex; mode=display">\cup \cap \setminus \subset \subseteq \subsetneq \supset \in \notin \emptyset \varnothing</script><pre><code>(5)表示排列使用\binom&#123;n+1&#125;&#123;2k&#125;或&#123;n+1 \choose 2k&#125;</code></pre><script type="math/tex; mode=display">\binom{n+1}{2k}</script><pre><code>(6)箭头：\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto: :</code></pre><script type="math/tex; mode=display">\to \rightarrow \leftarrow \Rightarrow \Leftarrow \mapsto</script><pre><code>(7)逻辑运算符：\land \lor \lnot \forall \exists \top \bot \vdash \vDash： </code></pre><script type="math/tex; mode=display">\land \lor \lnot \forall \exists \top \bot \vdash \vDash</script><pre><code>(8)\star \ast \oplus \circ \bullet : </code></pre><script type="math/tex; mode=display">\star \ast \oplus \circ \bullet</script><pre><code>(9)\approx \sim \cong \equiv \prec : </code></pre><script type="math/tex; mode=display">\approx \sim \cong \equiv \prec</script><pre><code>(10)\infty \aleph_o \nabla \partial \Im \Re : </code></pre><script type="math/tex; mode=display">\infty \aleph_o \nabla \partial \Im \Re</script><pre><code>(11)模运算 \pmode , 如 a \equiv b \pmod n : </code></pre><script type="math/tex; mode=display">a \equiv b \pmod n</script><pre><code>(12)\ldots与\cdots，其区别是dots的位置不同，ldots位置稍低，cdots位置居中</code></pre><script type="math/tex; mode=display">\ldots与\cdots</script><pre><code>(13)一些希腊字母具有变体形式，如\epsilon \varepsilon : ，\phi \varphi : </code></pre><script type="math/tex; mode=display">\epsilon \varepsilon，\phi \varphi</script><h3 id="间距"><a href="#间距" class="headerlink" title="间距"></a>间距</h3><pre><code>可以通过在ab间加入\,增加些许间隙，\;增加较宽间隙，\quad与\qquad会增加更大的间隙，如 ：a \quad b</code></pre><script type="math/tex; mode=display">a \quad b</script><h3 id="顶部符号"><a href="#顶部符号" class="headerlink" title="顶部符号"></a>顶部符号</h3><pre><code>(1)对于单字符，\hat x: </code></pre><script type="math/tex; mode=display">\hat x</script><pre><code>(2)对于多字符，\widehat &#123;xy&#125;: </code></pre><script type="math/tex; mode=display">\widehat {xy}</script><pre><code>(3)类似的还有 \overline , \vec , \overrightarrow , \dot , \ddot : </code></pre><script type="math/tex; mode=display">\overline {xyz}, \vec x, \overrightarrow x, \dot x, \ddot x</script><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><pre><code>$$\begin&#123;matrix&#125; 1 &amp; x &amp; x^2 \\ 1 &amp; y &amp; y^2 \\ 1 &amp; z &amp; z^2 \end&#123;matrix&#125;$$</code></pre><script type="math/tex; mode=display">\begin{matrix} 1 & x & x^2 \\ 1 & y & y^2 \\ 1 & z & z^2 \end{matrix}</script><pre><code>替换\begin&#123;matrix&#125;...\end&#123;matrix&#125;中的matrix为pmatrix , bmatrix , Bmatrix , vmatrix , Vmatrix.</code></pre><script type="math/tex; mode=display">\begin{pmatrix} 1 & x \\ 1 & y \end{pmatrix},\begin{bmatrix} 1 & x \\ 1 & y \end{bmatrix},\begin{Bmatrix} 1 & x \\ 1 & y \end{Bmatrix},\begin{vmatrix} 1 & x \\ 1 & y \end{vmatrix},\begin{Vmatrix} 1 & x \\ 1 & y \end{Vmatrix}</script><p>想要更加深入学 <code>Mathjax</code> 到 <a href="https://zhuanlan.zhihu.com/p/568747716">这篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathjax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法</title>
      <link href="/2023/08/10/markdown%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/08/10/markdown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>建站的第一件事就是先去学习了一下 <code>Markdown</code> 语法 , 方便对于博客的编写 。  </p><p> <code>Markdown</code> 对于文本的编辑与 <code>HTML</code> 相比可以说是非常的通俗易懂 , 下面是我对与 <code>Markdown</code> 常用语法使用的一些总结 。</p><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p> # ~ ######  一到六级标题</p><p># 一级标题</p><p>以此类推 </p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>在一行的末尾添加两个或多个空格 ，然后按回车键 , 即可创建一个换行 。</p><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>斜体： *斜体* ，  效果：<em>斜体</em></p><p>粗体： **粗体** ，  效果：<strong>粗体</strong></p><p>粗体+斜体：***粗体+斜体 *** ， 效果：<strong><em>粗体+斜体</em></strong></p><p>删除线  ~~删除线~~ ，效果：  <del>删除线</del></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在段落前添加一个 &gt; 符号 ，可嵌套其他元素 。</p><p>> this is my blog</p><blockquote><p>this is my blog</p><blockquote><ul><li>welcome!</li></ul></blockquote></blockquote><h3 id="列表语法"><a href="#列表语法" class="headerlink" title="列表语法"></a>列表语法</h3><ol><li><p>有序列表 ，可嵌套</p><ol><li>标题<ol><li>一级标题</li></ol></li><li>换行<ol><li>br</li></ol></li></ol></li></ol><ol><li><p>无序列表</p><p> - title<br> - br</p><ul><li>title</li><li>title</li></ul></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>`markdown` ，<code>markdown</code></p><p>``using namespace `std` `` ，<code>using namespace `std` </code> </p><p>代码块：将代码块的每一行缩进至少四个空格或一个制表符。</p><pre><code>typedef struct node&#123;    int x = x;&#125;</code></pre><p>代码块围栏：</p><p>``` C++</p><p> 代码围栏区域 </p><p>```<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">        <span class="type">int</span> x = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>超链接：</p><p>[超链接显示名](超链接地址 “超链接title”)</p><p><a href="https://godzillamonste.github.io" title="myblog">Jia</a></p><p>网站链接：</p><p>&lt; * <a href="https://markdown.com.cn">https://markdown.com.cn</a> * ></p><p>&lt; <em><a href="https://markdown.com.cn">https://markdown.com.cn</a></em> &gt;</p><p>可内嵌格式化链接，粗体，斜体，代码</p><p>图片链接：</p><p>![图片alt](图片链接 “图片title”)</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>格式化 Markdown 文档的字符，请在字符前面添加反斜杠字符 \ 。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>（—-）创建每列的标题，并使用管道（|）分隔每列。</p><p>| Syntax      | Description |<br>| —————- | —————- |<br>| Header      | Title       |<br>| Paragraph   | Text        |</p><div class="table-container"><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table></div><p>图形化表格制作：<a href="https://www.tablesgenerator.com/markdown_tables"> markdown 表格生成器 </a></p><hr><p>文章参考：<a href="https://markdown.com.cn"> markdown 官方文档 </a> </p>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
